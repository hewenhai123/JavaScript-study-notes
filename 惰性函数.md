## 惰性函数思想

> 自我理解

```apple js
    以牺牲第一次的性能换取以后每次调用的性能提升。
    
    只执行一次，在第一次调用的时候对分支进行判断，并且对函数本身进行重写，
    之后每次再次调用的时候直接return返回第一次已经计算的值，达到提高性能的目的。
    
    目前常用于浏览器兼容一次判断
    
适应环境： 
 1. 复杂的运算且只运行一次结果就不会再变。
 2. 频繁的调用。
```

* 示例

1. 原始调用方式

```apple js
   var numFn=function(){
    var val='';
    for(var i=0;i<100000000;i++){
        val=i*i;  
    }
    return val;
   }
* 原始方法在每次调用的时候都会从新执行numFn里面的for循环，
  每次都会执行100000次后再返回计算后的值val
  
* 实测结果：
 init：  q: 10.033935546875ms
    1：  c: 6.453125ms
    2：  c: 5.4111328125ms
    3：  c: 5.877197265625ms
    4：  c: 5.46826171875ms
    5：  c: 5.8251953125ms

```

2. 惰性函数思想 

```apple js
   var numFn=function() {
     var val='';
     for(var i=0;i<100000000;i++){
         val=i*i;
     }
     return numFn=function() {
       return val;
     }
   }

* 利用惰性函数思想解决这个问题，牺牲第一次的性能，在第一次运行时计算出结果后，
  return 重写当前的函数，在函数中直接返回计算地方结果。以后每次调用这个方法时，
  就会直接返回已经计算出的结果，避免了每次都从新的执行for循环。
  
* 以牺牲第一次的性能来提高以后多次调用的性能
  
* 实测结果：
  init：  q: 189.350341796875ms
     1：  c: 0.008056640625ms
     2：  c: 0.001953125ms
     3：  c: 0.015869140625ms
     4：  c: 0.0009765625ms
     5：  c: 0.0009765625ms
```
