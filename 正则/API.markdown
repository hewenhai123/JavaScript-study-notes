
* 元字符

| 名称 |                         描述                                 |
|:---:|---|
| \d  |   匹配一个0-9的数字,相当于[0-9]                               | |
| \D  |   和\d相反，匹配一个除了0-9的任意数字                          | | 
| \w  |   匹配一个0-9、a-z、A-Z、_ 的数字或者字符相当于[0-9a-zA-Z]    | | 
| \s  |   匹配一个空白字符（空格、制表符（tab键--》4个空格））          | | 
| \b  |   匹配一个单词边界"welcome to zhufeng" 一个单词左右两边都是边界 | | 
| \t  |   匹配一个制表符（tab键--》4个空格）                           | | 
| \n  |   匹配一个换行                                                | |
| .   |   匹配一个除了\n以外的任意字符                                 | | 
| ^   |   以某一个元字符开头                                          | | 
| $   |   以某一个元字符结尾                                          | |
| \   |   转义字符 把特殊意义的元字符转换为本意，把本意转换为特殊意义元字符   | |
| x&#124;y  |   匹配一个除了\n以外的任意字符                          | |
| [xyz]    |   x、y、z中任意一个字符                                 | | 
| [^xyz]   |   除x、y、z中任意一个字符                               | |
| [a-z]    |   匹配a-z中的任意一个字符                                | |
| （）      |   正则中的分组                                          | |
| 关于 []   |   [+] 中括号中出现的所有字符都代表的是本身的意思            | |    
|          |   /^[12-65]$/ 这个不是12-65，而是1/2-6/5 三者中的一个     | | 
|          |   /[12-65]/ 匹配包含 1/2/6/5  12-65之间                | |
| 关于（）  |   分组的作用是改变默认的优先级                             | |
| | 可以在捕获大正则的内容同时，把分组匹配的内容也进行捕获-》分组捕获          | |
| | 分组引用，例如：/^(\d)(\w)\2\1$/, 这里的\2是和第二个分组出现完全相同的内容，\1是和第一个分组出现完全相同的内容，例如："0aa0",就符合     | |
| | 例如: /^18&#124;19$/ 以18开头或者以19结尾的字符串都匹配               | |
| | 例如: /^18&#124;19$/,181、189、119、819、1819...都符合,而不是我们认为的18或19，但是改成/^(18&#124;19)$/就是单纯的18或19了      | |
| | 例如: /18&#124;19/  只要包含18或者19的都匹配                       | |
| 代表数量的元字符 |                                                  | |
|    *     |     0到多个                                             | |
|    +     |     1到多个                                             | |
|    ？     |     0到一个                                             | |
|    {n}   |     出现n次                                             | |
|   {n，}  |     出现n次到次                                         | |
|   {n，m}  |     出现n到m次                                        | |
| 关于？的几种情况 |                                                 | |
| a        |    放在非量词元字符后面，代表出现0-1次                      | |
| b        |    放在量词元字符后面，代表取消捕获时的贪婪性                 | |
| | 例如 :reg=/\d+/;reg.exec("2015")-> "2015"                       | |
| |      reg=/\d+?/; reg.exec("2015")->"2"                         | |
| c        | 在分组开头加?:,代表当前的分组只是进行匹配不进行捕获               | |
| | 例如 ：reg=/^(?:\d+)$/                                           | |
| d        | 在分组开头加?=,正向预查                                       | |
| | 例如 ：reg=/^zhuf(?=1&#124;2)$/,只有"zhuf1"和 "zhuf2"符合             | |
| e        | 在分组开头加?!,负向预查                                       | |
| | 例如 ：reg=/^zhuf(?!1&#124;2)$/,只有"zhuf1"和"zhuf2"不符合，"zhuf(任何东西)"都符合  | |
|  注意：     |   | |
| | 除了以上的,在字面量方式中,我们出现的其他任意字符代表的都是自己本身的意思       | |
| | 例如 ：var num=12;var reg=/^\w"+num+"$/; ->这里"+num+"不是把变量的值拼接,而这里的不管是"还是+都是元字符 | |
| | ->对于需要拼接字符串和变量的方式我们只能使用实例方式创建正则                 | |


*  修饰符

| 名称 | 描述  |
|:---:|:---|
|   i    |   ignoreCase 忽略字母的大小写                            |
|   g    |   global 全局匹配（加上 g 可以解决正则匹配时的懒惰性）        |
|   m    |   multiline 多行匹配                                    |

***
***

* 使用

|  名称    |               描述                                   |
|:---:|:---|
|   test   |           语法   reg.test(string)                       |
| |  true就是成功   false匹配不成功                          |
|   exec   |           语法   reg.exec(string)                       |
| |  首先去匹配，匹配成功在捕获，返回一个数组，如果匹配不成功返回的是null        |
| |  正则的捕获即懒惰又贪婪                                             |
| |  解决懒惰性，在正则的末尾增加全局修饰符g                               |
| |  解决贪婪，在量词后面修饰符?                                 |





    